# Vue 3 Composition API 기본 이해

## 📌 1. Composition API란?

- Vue 3에서 도입된 새로운 방식의 API로, 기존 Options API의 단점을 보완합니다.
- `setup()` 함수를 중심으로 컴포넌트의 로직을 구성합니다.
- 코드 재사용성, 유지보수성, 타입 지원에서 장점이 있습니다.

---

## 🧪 2. `setup()` 함수란?

- 모든 Composition API 로직은 `setup()` 함수 내에서 정의됩니다.
- 컴포넌트가 생성되기 **이전에 호출**됩니다.
- 반환된 값은 템플릿에서 사용할 수 있습니다.

```js
<script setup>
import { ref } from 'vue';

const count = ref(0);
const increment = () => count.value++;
</script>

<template>
  <button @click="increment">Count: {{ count }}</button>
</template>
```

---

## 🔁 3. 반응형 변수: `ref`와 `reactive`

### ✅ ref
- 기본형 타입의 반응형 상태 생성에 사용합니다. 단일 값, 단일 객체, 원시 타입 (number, string, boolean 등)
- 값에 접근 시 .value 필요 (템플릿에서는 자동 풀림)
```js
const count = ref(0);
console.log(count.value); // 0
```

### ✅ reactive
- 객체나 배열 등 복합형 데이터를 반응형으로 만듭니다.
- 속성 직접 접근
```js
const user = reactive({ name: 'Alice', age: 25 });
console.log(user.name); // Alice
```

> ref 객체 안에 객체를 넣으면 어떻게 되는가?
- ref 안에 객체를 넣으면, 그 객체 자체는 자동으로 reactive(반응형) 처리가 됩니다.
- .value 접근을 하지 않으려면 reactive 로 사용하는 것이 편합니다.
```js

<script setup>
import { ref } from 'vue'

const user = ref({
  name: '홍길동',
  age: 20
})

function updateName() {
  user.value.name = '성춘향'
}
</script>

<template>
  <div>
    <p>이름: {{ user.value.name }}</p>
    <p>나이: {{ user.value.age }}</p>
    <button @click="updateName">이름 변경</button>
  </div>
</template>

```


### ✅  ref vs reactive: 권장 사용법 정리

| 상황 | 추천 방식 | 이유 |
|:----|:----------|:----|
| **단일 값 (number, string 등)** | `ref` | 간단하게 사용할 수 있고 직관적 |
| **객체나 배열** | `reactive` | 구조가 복잡하므로 속성 직접 접근이 편리 |
| **객체 하나를 개별 관리** | `ref` | 값 교체 중심일 경우 관리가 편함 |
| **Form 데이터처럼 복잡한 구조** | `reactive` | 전체 구조를 일괄적으로 관리하기 쉬움 |
| **배열을 관리할 때** | `reactive` or `ref([])` | 상황에 따라 다름 (조작 방식 차이 있음) |

---



## 🔍 4. 계산된 속성: `computed`

- 기존 `computed` 옵션과 유사하게 동작합니다.
```js
const firstName = ref('John');
const lastName = ref('Doe');
const fullName = computed(() => `${firstName.value} ${lastName.value}`);
```

---

## 👀 5. 감시자: `watch`, `watchEffect`

### watch
- watch는 하나 이상의 반응형 데이터 소스(ref, reactive, getter 함수 등)를 명시적으로 지정하여 그 값이 변경될 때 콜백을 실행합니다.
- 명시적으로 감시할 대상을 지정합니다.
- 이전 값과 새로운 값을 모두 사용할 수 있습니다.
- 여러 데이터 소스를 배열로 감시할 수 있습니다.
- 기본적으로 lazy하게 동작합니다 (즉, 초기 실행은 하지 않음).

```js
watch(count, (newVal, oldVal) => {
  console.log(`count가 ${oldVal}에서 ${newVal}로 변경됨`);
});
```

### watchEffect
- watchEffect는 코드 안에서 자동으로 사용된 반응형 데이터를 추적하여, 관련된 값이 변하면 콜백을 다시 실행합니다.
- 의존성을 자동으로 수집합니다.
- 별도로 감시할 대상을 지정할 필요가 없으며, 즉시 실행됩니다.
- watch보다 간단한 경우에 사용하기 좋습니다.

```js
watchEffect(() => {
  console.log(`count는 ${count.value}`);
});
```

---

## ⏳ 6. 생명주기 훅

- Composition API에서는 아래와 같이 라이프사이클 훅을 사용합니다.

```js
import { onMounted, onUnmounted } from 'vue';

onMounted(() => {
  console.log('컴포넌트가 마운트됨');
});

onUnmounted(() => {
  console.log('컴포넌트가 언마운트됨');
});
```

---

## ✅ 정리

- Composition API는 Vue 3에서 가장 중요한 변화 중 하나입니다.
- `ref`, `reactive`, `computed`, `watch`, `setup()`을 기반으로 반응형 UI를 구성합니다.
- 다음 시간에는 템플릿 문법 및 디렉티브를 다룹니다.
